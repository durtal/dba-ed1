---
title: 'Chapter 6: Exercises'
---

```{r echo=FALSE}
# Bayesian updating for Bernoulli likelihood and prior specified on a grid.
# args:
#   theta:      vector of theta values, all between 0 and 1
#   pTheta:     vector of corresponding probability masses
#   Data:       vector of 1's and 0's, where 1 corresponds to a, and 0 b
#   credib:     probability mass of the HDI
#   nToPlot:    number of grid points to plot
#   plot:       plot prior, likelihood and posterior
# output:
#   pThetaGivenData:    vector of posterior probability masses over theta
BernGrid <- function(theta, pTheta, Data, credib = 0.95, nToPlot = length(theta),
                     plot = TRUE) {
    
    # summarise data
    z <- sum(Data == 1)
    N <- length(Data)
    # compute the likelihood of thhe Data for each value of theta
    pDataGivenTheta <- theta^z * (1 - theta)^(N-z)
    # compute the evidence and the posterior
    pData <- sum(pDataGivenTheta * pTheta)
    pThetaGivenData <- pDataGivenTheta * pTheta / pData
    
    if(plot) {
        layout(matrix(c(1,2,3), nrow = 3, ncol = 1, byrow = FALSE))
        par(mar = c(3,3,1,0), mgp = c(2,1,0), mai = c(0.5, 0.5, 0.3, 0.1))
        dotsize <- 5
        # if comb has a lot of intervals, reduce to a subset
        nteeth <- length(theta)
        if(nteeth > nToPlot) {
            thinIdx <- seq(1, nteeth, round(nteeth / nToPlot))
            if(length(thinIdx) < length(theta)) {
                thinIdx <- c(thinIdx, nteeth)
            }
        } else {
            thinIdx <- 1:nteeth
        }
        meanTheta <- sum(theta * pTheta)
        # plot prior
        plot(theta[thinIdx], pTheta[thinIdx], type = "p", pch = ".", cex = dotsize,
             xlim = c(0, 1), ylim = c(0, 1.1*max(pThetaGivenData)), xlab = bquote(theta),
             ylab = bquote(p(theta)), main = "Prior", col = "skyblue")
        if(meanTheta > .5) {
            textx <- 0
            textadj <- c(0,1)
        } else {
            textx <- 1
            textadj <- c(1,1)
        }
        text(textx, 1.0*max(pThetaGivenData), bquote("Mean(" * theta * ")=" * .(signif(meanTheta, 3))), adj = textadj)
        # plot likelihood
        plot(theta[thinIdx], pDataGivenTheta[thinIdx], type = "p", pch = ".", cex = dotsize,
             xlim = c(0, 1), ylim = c(0, 1.1* max(pDataGivenTheta)),
             xlab = bquote(theta), ylab = bquote("p(D|" * theta * ")"),
             main = "Likelihood", col = "skyblue")
        if(z > .5*N) {
            textx <- 0
            textadj <- c(0,1)
        } else {
            textx <- 1
            textadj <- c(1,1)
        }
        text(textx, 1*max(pDataGivenTheta), 
             bquote("Data: z=" * .(z) * ", N=" * .(N)), adj = textadj)
        # plot the posterior
        meanThetaGivenData <- sum(theta * pThetaGivenData)
        plot(theta[thinIdx], pThetaGivenData[thinIdx], type = "p", pch = ".", cex = dotsize,
             xlim = c(0, 1), ylim = c(0, 1.1*max(pThetaGivenData)),
             xlab = bquote(theta), ylab = bquote("p(" * theta * "|D)"),
             main = "Posterior", col = "skyblue")
        if(meanThetaGivenData > .5) {
            textx <- 0
            textadj <- c(0,1)
        } else {
            textx <- 1
            textadj <- c(1,1)
        }
        text(textx, 1*max(pThetaGivenData), 
             bquote("Mean(" * theta * "|D)=" * .(signif(meanThetaGivenData, 3))),
             adj = textadj)
        text(textx, 0.75 * max(pThetaGivenData),
             bquote("p(D)=" * .(signif(pData, 3))), adj = textadj)
        
        # HDI 
        HDIinfo <- HDIofGrid(pThetaGivenData, credMass = credib)
        points(theta[HDIinfo$indices], rep(HDIinfo$height, length(HDIinfo$indices)),
               pch = "-")
        text(mean(theta[HDIinfo$indices]), HDIinfo$height,
             bquote(.(100*signif(HDIinfo$mass,3))*"% HDI"), adj = c(0.5, -1.5))
        inLim <- HDIinfo$indices[1]
        
        for ( idx in 2:(length(HDIinfo$indices)-1) ) {
            if ( ( HDIinfo$indices[idx] != HDIinfo$indices[idx-1]+1 ) | ( HDIinfo$indices[idx] != HDIinfo$indices[idx+1]-1 ) ) { 
                inLim = c(inLim,HDIinfo$indices[idx]) 
            }
        }
        inLim <- c(inLim, HDIinfo$indices[length(HDIinfo$indices)])
        for(idx in inLim) {
            lines(c(theta[idx], theta[idx]), c(-0.5, HDIinfo$height), type = "l",
                  lty = 2, lwd = 1.2)
            text(theta[idx], HDIinfo$height, bquote(.(round(theta[idx], 3))),
                 adj = c(0.5, -0.1))
        }
    }
    return(pThetaGivenData)
}

# calculate HDI on grid
# args:
#   probMassVec:        vector of probability masses at each grid point
#   credMass:           desired mass of the HDI region
# output:
#   list with components:
#       indices:        vector of indices that are in the HDI
#       mass:           the total mass of the included indices
#       height:         the smallest component probability mass in the HDI
HDIofGrid <- function(probMassVec, credMass = 0.95) {
    sortedProbMass <- sort(probMassVec, decreasing = TRUE)
    HDIheightIdx <- min(which(cumsum(sortedProbMass) >= credMass))
    HDIheight <- sortedProbMass[HDIheightIdx]
    HDImass <- sum(probMassVec[probMassVec >= HDIheight])
    return(list(indices = which(probMassVec >= HDIheight),
                mass = HDImass, height = HDIheight))
}
```

## Inferring a Binomial Proportion via Grid Approximation

### 6.1

Consider this R code for discretising a $beta(\theta | 8, 4)$ distribution:

```{r}
nIntervals <- 10
width <- 1 / nIntervals
theta <- seq(from = width / 2, to = 1 - width / 2, by = width)
approxMass <- dbeta(theta, 8, 4) * width
pTheta <- approxMass / sum(approxMass)
```

> What is the value of `sum(approxMass)`? Why is it not exactly 1?

`approxMass =``r sum(approxMass)`, it does not equal 1 because intervals are discrete, the smaller the intervals, the closer `sum(approxMass)` would be to 1.

> Suppose we use the following code to define the grid of points instead:

```{r}
theta <- seq(from = 0, to = 1, by = width)
```

> why is this appropriate?

Each interval value is discrete, so the low (0) and high (1) values would refer to invalid theta values $\left[ 0 < \theta > 1 \right]$.

### 6.2

Suppose we have a coin that has a head on one side and a tail on the other.  We think it might be fair, or it might be a trick coin that is heavily biased toward heads or tails.  We want to express this prior belief with a single prior over $\theta$.  Therefore the prior needs to have three peaks: one near 0, one around 0.5 and one near 1.  But these peaks are not just isolated spikes, because we have uncertainty about the actual value of $\theta$

> Express your prior belief as a list of probability masses over a fairly dense grid of $\theta$ values.  Remember to set a gradual decline around the three peaks.  Justify you choice.  You can specify the peaks however you want, but one simple way is something like:

```{r eval=FALSE}
pTheta <- c(50:1, rep(1, 50), 1:50, 50:1, rep(1, 50), 1:50)
pTheta <- pTheta / sum(pTheta)
width <- 1 / length(pTheta)
theta <- seq(from = width / 2, to = 1 - width / 2, by = width)
plot(theta, pTheta, type = "l")
```

> Suppose you flip the coin 20 times and get 15 heads.  Use the R function of Section 6.7.1 ([BernGrid.R](https://github.com/durtal/dba-ed1/blob/master/code-data/BernGrid.R)) to display the posterior beliefs.  Include the R code that specified the prior values

```{r}
pTheta <- c(50:1, rep(1, 50), 1:50, 50:1, rep(1, 50), 1:50)
pTheta <- pTheta / sum(pTheta)
width <- 1 / length(pTheta)
theta <- seq(from = width / 2, to = 1 - width / 2, by = width)
post <- BernGrid(theta = theta, pTheta = pTheta, Data = c(rep(1,15), rep(0,5)), plot = TRUE)
```

### 6.3

> Using the same prior that was used in the previous exercise, suppose you flip the coin just 4 times and get 3 heads.  Use the R function of Section 6.7.1 ([BernGrid.R](https://github.com/durtal/dba-ed1/blob/master/code-data/BernGrid.R)) to display the posterior.

```{r}
posterior6.3a <- BernGrid(theta = theta, pTheta = pTheta, Data = c(rep(1,3), rep(0,1)), plot = TRUE)
```

> Suppose we flip the coin an additional 16 times and get 12 heads. Now what is the posterior distribution?  To answer this question, use the posterior distribution that is output by the function in the previous part as the prior for this part.

```{r}
posterior6.3b <- BernGrid(theta = theta, pTheta = posterior6.3a, Data = c(rep(1,12), rep(0,4)), plot = TRUE)
```

### 6.4

Suppose an election is approaching and you are interested in knowing whether the general population prefers candidate A or candidate B.  A recently published poll in the newspaper states that of 100 randomly sampled people, 58 preferred candidate A, and the remainder preferred candidate B.

> Suppose that before the newspaper poll your prior belief was a uniform distribution.  What is the 95% HDI on your beliefs after learning of the newspaper poll results.

```{r}
pTheta <- rep(1, 1000)
pTheta <- pTheta / sum(pTheta)
width <- 1 / length(pTheta)
theta <- seq(from = width / 2, to = 1-width / 2, by = width)
posterior6.4a <- BernGrid(theta = theta, pTheta = pTheta, Data = c(rep(1, 58), rep(0,42)))
```

> Based on the newspaper poll, is it credible to believe that the population is equally divided in its preferences for each candidate.

Yes, it is credible, as the 95% HDI includes 0.5

> You want to conduct a follow up poll to narrow down your estimate of the population's preference.  In your follow up poll, you randomly sample 100 people and find that 57 prefer candidate A and the remainder prefer candidate B.  Assuming that people's opinions have not changed between polls, what is the 95% HDI on the posterior

```{r}
posterior6.4c <- BernGrid(theta = theta, pTheta = posterior6.4a, Data = c(rep(1, 57), rep(0, 43)))
```

> Based on your follow up poll, is it credible to believe that the population is equally divided in its preferences for each candidate.

The 95% HDI does not include 0.5, so it is not credible to believe that the population is not divided between each candidate.

### 6.5

Suppose that the newly hired quality control manager at the ACME Widget factory is trying to convince the CEO that the proportion of defective widgets coming off the assembly line is less than 10%.  No previous data are available regarding the defect rate at the factory.  The manager randomly samples 500 widgets, and she finds that 28 of them are defective...

> What do you conclude about the defect rate?

There is no uniquely correct prior, we can imagine the CEO is very skeptical about quality, and believes that even a very high defect rate is possible, although not as probable as low defect rates.  Therefore the prior used here is linearly decreasing across the domain

```{r}
pTheta <- 1000:1
pTheta <- pTheta / sum(pTheta)
width <- 1 / length(pTheta)
theta <- seq(from = width / 2, to = 1 - width / 2, by = width)
posterior6.5a <- BernGrid(theta = theta, pTheta = pTheta, Data = c(rep(1,28), rep(0, 500-28)))
```

As an comparison, let's look at a uniform prior

```{r}
pTheta <- rep(1, 1000)
pTheta <- pTheta / sum(pTheta)
width <- 1 / length(pTheta)
theta <- seq(from = width / 2, to = 1 - width / 2, by = width)
posterior6.5b <- BernGrid(theta = theta, pTheta = pTheta, Data = c(rep(1, 28), rep(0, 500-28)))
```

### 6.6

> Suppose we believe that a coin is biased to come up heads, and we describe our prior belief as quadratically increasing: $p(\theta)$ is proportional to $\theta^2$.  Suppose we flip the coin four times and observe two heads and two tails.  Based on the posterior distribution, what is the predicted probability that the next flip will return a head?

```{r}
binwidth <- 1 / 1000
thetagrid <- seq(from = binwidth / 2, to = 1 - binwidth / 2, by = binwidth)
relprob <- thetagrid^2
prior <- relprob / sum(relprob)
posterior6.6a <- BernGrid(theta = thetagrid, pTheta = prior, Data = c(rep(1,2), rep(0, 2)))
(predprob <- sum(thetagrid * posterior6.6a))
```

### 6.7

Suppose we have competing beliefs about the bias of a coin: One person believes the coin is head biased, and the second person believes the coin is tail biased.  To make this specific, suppose the head-biased prior is $p(\theta | M1)$ proportional to $\theta^2$ and the tail-based prior is $p(\theta | M2)$ proportional to $(1 - \theta)^2$.

> Suppose that we are equally willing to entertain the two models, so $p(M1) = p(M2) = 0.5$.  We flip the coin $N = 8$ times and observe $z = 6$ heads.  What is the ration of posterior beliefs (ie Bayes Factor)?

```{r}
binwidth <- 1 / 1000
thetagrid <- seq(from = binwidth / 2, to = 1 - binwidth / 2, by = binwidth)
# model 1
M1relprob <- thetagrid ^ 2
M1prior <- M1relprob / sum(M1relprob)
posterior6.71 <- BernGrid(theta = thetagrid, pTheta = M1prior, Data = c(rep(1, 6), rep(0, 2)))

# model2
M2relprob <- (1 - thetagrid) ^ 2
M2prior <- M2relprob / sum(M2relprob)
posterior6.72 <- BernGrid(theta = thetagrid, pTheta = M2prior, Data = c(rep(1, 6), rep(0, 2)))
```

The posteriors show that $p(D | M1) = 0.00606$ and $p(D | M2) = 0.00130$, so the Bayes Factor is $0.00606 / 0.00130 = 4.66$

### 6.8

A pharmaceutical company claims that its new drug increases the probability that couples who take the drug will conceive a boy.  The company has published no studies regarding this claim, so there is no public knowledge regarding the efficacy of the drug.

Suppose you conduct a study in which 50 couples, sampled at random from the general population, take the drug during a period of time while trying to conceive a baby.  Suppose that eventually wall couples conceive; there are 30 boys and 20 girls (no multiple births).

> You want to estimate the probability of conceiving a boy for couples who take the drug.  What is an appropriate prior belief distribution?  It cannot be the general population probability, because that is a highly peaked distribution near 0.5 that refers to non-drugged couples.  Instead, the prior needs to relfect our pre-experiment uncertainty in the effect of the drug.  Discuss your choice of prior with this in mind.

A skeptical prior would be to use a prior based on the general population, highly peaked around 0.5, as it wouuld require a lot of data in order for beliefs to move.  However, it seems reasonable that the prior should be centered around 0.5, but not as highly peaked. A prior of $beta(\theta | 5,5)$ is appropriate.

> Using your prior from the previous part, plot the posterior and decide whether it is credible that couples who take drugs have a 50% chance of conceiving a boy.

```{r echo=FALSE}
# Bayesian updating for Bernoulli likelihood and beta prior.
# args:
#   priorShape  : vector of parameter values for the prior beta distribution
#   dataVec     : vector of 1's and 0's
#   credMass    : the probability mass of the HDI
#   plot        : plot prior, likelihood and posterior
# output:
#   postShape   : vector of parameter values for the posterior beta distribution
BernBeta <- function(priorShape, dataVec, credMass = 0.95, plot = TRUE) {
   
    # check inputs
    if(length(priorShape) != 2) stop("priorShape must have two, numeric, components.")
    if(any(priorShape <= 0)) stop("priorShape components must be positive.")
    if(any(dataVec != 1 & dataVec !=0)) stop("dataVec must be a vector of 1's and 0's.")
    if(credMass <= 0 | credMass >= 1) stop("credMass must be between 0 and 1.")
    
    # rename prior shape parameters
    a <- priorShape[1]
    b <- priorShape[2]
    # summarise new data
    z <- sum(dataVec == 1)
    N <- length(dataVec)
    # compute posterior shape parameters
    postShape <- c(a + z, b + N - z)
    # compute the evidence, p(D)
    pData <- beta(z + a, N - z + b) / beta(a, b)
    # determine limits of Highest Density Interval
    hpdLim <- HDIofICDF(ICDFname = qbeta, shape1 = postShape[1], shape2 = postShape[2],
                        credMass = credMass)
    if(plot) {
        # plot everything
        binwidth <- 0.005
        Theta <- seq(from = binwidth / 2, to = 1 - (binwidth / 2), by = binwidth)
        pTheta <- dbeta(Theta, a, b)
        pDataGivenTheta <- Theta^z * (1 - Theta)^(N-z)
        pThetaGivenData <- dbeta(Theta, a + z, b + N - z)
        
        layout(matrix(c(1,2,3), nrow = 3, ncol = 1, byrow = TRUE))
        par(mar = c(3,3,1,0), mgp = c(2,1,0), mai = c(0.5, 0.5, 0.3, 0.1))
        maxY <- max(c(pTheta, pThetaGivenData))
        # plot prior
        plot(Theta, pTheta, type = "l", lwd = 3, xlim = c(0, 1), ylim = c(0, maxY),
             xlab = bquote(theta), ylab = bquote(p(theta)), main = "Prior",
             col = "#FF0000")
        if(a > b) {
            textx <- 0
            textadj <- c(0,1)
        } else {
            textx <- 1
            textadj <- c(1, 1)
        }
        text(textx, 1.0*max(pThetaGivenData), bquote("beta(" * theta * "|" * .(a) * "," * .(b) * ")"), adj = textadj)
        
        # plot likelihood
        plot(Theta, pDataGivenTheta, type = "l", lwd = 3, 
             xlim = c(0, 1), ylim = c(0, 1.1*max(pDataGivenTheta)), 
             xlab = bquote(theta), ylab = bquote("p(D|" * theta * ")"),
             main = "Likelihood", col = "#FF0000")
        if(z > 0.5*N) {
            textx <- 0
            textadj <- c(0,1)
        } else {
            textx <- 1
            textadj <- c(1, 1)
        }
        text(textx, 1.0*max(pDataGivenTheta), bquote("Data: z=" * .(z) * ",N=" * .(N)), adj = textadj)
        
        # plot posterior
        plot(Theta, pThetaGivenData, type = "l", lwd = 3, 
             xlim = c(0, 1), ylim = c(0, maxY), 
             xlab = bquote(theta), ylab = bquote("p(" * theta * "|D)"), 
             main = "Posterior", col = "#FF0000")
        if(a + z > b + N - z) {
            textx <- 0
            textadj <- c(0, 1)
        } else {
            textx <- 1
            textadj <- c(1, 1)
        }
        text(textx, 1*max(pThetaGivenData), bquote("beta(" * theta * "|" * .(a + z) * "," * .(b + N - z) * ")"), adj = textadj)
        text(textx, 0.75*max(pThetaGivenData), bquote("p(D)=" * .(signif(pData, 3))), adj = textadj)
        
        # mark the HDI in the posterior
        hpdHt <- mean(c(dbeta(hpdLim[1], a+z, b+N-z), dbeta(hpdLim[2], a+z, b+N-z)))
        lines(c(hpdLim[1], hpdLim[1]), c(-0.5, hpdHt), type = "l", lty = 2, lwd = 1.25)
        lines(c(hpdLim[2], hpdLim[2]), c(-0.5, hpdHt), type = "l", lty = 2, lwd = 1.25)
        lines(hpdLim, c(hpdHt, hpdHt), type = "l", lwd = 1.5)
        text(mean(hpdLim), hpdHt, bquote(.(100*credMass) * "% HDI"), adj = c(0.5, -1))
        text(hpdLim[1], hpdHt, bquote(.(round(hpdLim[1], 3))), adj = c(1.1, -0.1))
        text(hpdLim[2], hpdHt, bquote(.(round(hpdLim[2], 3))), adj = c(-0.1, -0.1))        
    }

    # return posterior shape
    return(postShape)
}
# Compute HDI
# args:
#   ICDFname    : is R's name for inverse cumulative density function of the distribution
#   credMass    : desired mass of the HDI region
#   tol         : is passed to R's optimise function
# output:
#   HDI         : highest density interval limits in a vector
HDIofICDF <- function(ICDFname, credMass = 0.95, tol = 1e-8, ...) {
    
    incredMass <- 1 - credMass
    intervalWidth <- function(lowTrailPr, ICDFname, credMass, ...) {
        ICDFname(credMass + lowTrailPr, ...) - ICDFname(lowTrailPr, ...)
    }
    optInfo <- optimise(intervalWidth, c(0, incredMass), ICDFname = ICDFname, 
                        credMass = credMass, tol = tol, ...)
    HDIlowTailPr <- optInfo$minimum
    return(c(ICDFname(HDIlowTailPr, ...), ICDFname(credMass + HDIlowTailPr, ...)))
}
```

We can use the BernBeta function from [Chapter 5](chapter5-exercises.html).  The HDI in the posterior includes 0.5, so the manufacturer's claim should not be believed.

```{r}
posterior6.8 <- BernBeta(c(5,5), c(rep(1, 30), rep(0,20)))
```

> Suppose that the drug manufacturers make a strong claim that their drug sets the probability of conceiving a boy to nearly 60%, with high certainty.  Suppose you represent that claim by a $beta(\theta | 60, 40)$ prior.  Compare that claim against the skeptic who says there is no effect of the drug, and the probability of conceiving a boy is represented by a $beta(\theta | 50, 50)$ prior.  What is the value of $p(D)$ for each prior?  What is the posterior belief in each claim?

<div class="row">
<div class="col-sm-6">
```{r}
posterior6.8a <- BernBeta(c(60, 40), c(rep(1, 30), rep(0, 20)))
```
</div>
<div class="col-sm-6">
```{r}
posterior6.8b <- BernBeta(c(50, 50), c(rep(1, 30), rep(0, 20)))
```
</div>
</div>

The Bayes Factor is $1.98e-15 / 1.01e-15 = 1.96$ in favour of the 60-40 prior.  This is **not** the posterior odds, however, because we have to factor in the prior odds of the model priors.  Suppose for example, that $p(60-40)$ prior is 0.33 and $p(50-50)$ prior is 0.67.  Then the posterior odds are:

$$\begin{align}
\frac{p(60-40 prior | D)}{p(50-50 prior | D)}
& = \frac{p(D | 60-40 prior)}{\frac{p(D | 50-50 prior) * p(60-40 prior)}{p(50-50 prior | D)}} \\
& = 1.96 * \frac{0.33}{0.67} \\
& = 0.97
\end{align}$$

